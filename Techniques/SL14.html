<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US"><head><title>SL14: Providing Custom Control Key Handling for Keyboard Functionality
    			in Silverlight | Techniques for WCAG 2.0
              </title><link rel="canonical" href="http://www.w3.org/TR/WCAG20-TECHS/SL14.html"/><link rel="stylesheet" type="text/css" href="https://www.w3.org/StyleSheets/TR/2016/W3C-WG-NOTE.css"/><link rel="stylesheet" type="text/css" href="additional.css"/><link rel="stylesheet" type="text/css" href="slicenav.css"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/></head><body class="slices toc-inline"><div id="masthead"><p class="logo"><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C"/></a></p><p class="collectiontitle"><a href="./">Techniques for WCAG 2.0</a></p></div><div id="skipnav"><p class="skipnav"><a href="#maincontent">Skip to Content (Press Enter)</a></p></div><a name="top"> </a><!-- TOP NAVIGATION BAR --><ul id="navigation"><li><strong><a href="Overview.html#contents" title="Table of Contents">Contents</a></strong></li><li><strong><a href="intro.html" title="Introduction to Techniques for WCAG 2.0"><abbr title="Introduction">Intro</abbr></a></strong></li><li><a title="SL13: Providing A Style Switcher To Switch To High Contrast" href="SL13.html"><strong>Previous: </strong>
        Technique SL13</a></li><li><a title="SL15: Providing Keyboard Shortcuts that Work Across the Entire Silverlight&#xA;    &#x9;&#x9;&#x9;Application" href="SL15.html"><strong>Next: </strong>
        Technique SL15</a></li></ul><div class="navtoc"><p>On this page:</p><ul id="navbar"><li><a href="#SL14-disclaimer">Important Information about Techniques</a></li><li><a href="#SL14-applicability">Applicability</a></li><li><a href="#SL14-description">Description</a></li><li><a href="#SL14-examples">Examples</a></li><li><a href="#SL14-resources">Resources</a></li><li><a href="#SL14-related-techs">Related Techniques</a></li><li><a href="#SL14-tests">Tests</a></li></ul></div><div class="skiptarget"><a id="maincontent">-</a></div> <h1><a name="SL14" id="SL14"> </a>SL14: Providing Custom Control Key Handling for Keyboard Functionality
    			in Silverlight</h1><div id="SL14-disclaimer"><h2>Important Information about Techniques</h2><p>See <a href="http://www.w3.org/TR/2016/NOTE-UNDERSTANDING-WCAG20-20160317/understanding-techniques.html">Understanding Techniques for WCAG Success Criteria</a> for important information about the usage of these informative techniques and how they relate to the normative WCAG 2.0 success criteria. The Applicability section explains the scope of the technique, and the presence of techniques for a specific technology does not imply that the technology can be used in all situations to create content that meets WCAG 2.0.</p></div><div class="applicability"><h2 id="SL14-applicability">Applicability</h2><div class="textbody"><ul><li><p> Microsoft Silverlight, versions 3 and greater </p></li><li><p> Silverlight managed programming model and Silverlight XAML </p></li></ul></div></div><p class="referenced">This technique relates to:</p><ul><li><a href="http://www.w3.org/TR/2008/REC-WCAG20-20081211/#keyboard-operation-keyboard-operable">
				Success Criterion 2.1.1 (Keyboard)</a><ul><li><a href="http://www.w3.org/WAI/WCAG20/quickref/20160105/#keyboard-operation-keyboard-operable">
						How to Meet 2.1.1 (Keyboard)
					</a></li><li><a href="http://www.w3.org/TR/2016/NOTE-UNDERSTANDING-WCAG20-20160317/keyboard-operation-keyboard-operable.html">
						Understanding Success Criterion 2.1.1 (Keyboard)
					</a></li></ul></li><li><a href="http://www.w3.org/TR/2008/REC-WCAG20-20081211/#keyboard-operation-all-funcs">
				Success Criterion 2.1.3 (Keyboard (No Exception))</a><ul><li><a href="http://www.w3.org/WAI/WCAG20/quickref/20160105/#keyboard-operation-all-funcs">
						How to Meet 2.1.3 (Keyboard (No Exception))
					</a></li><li><a href="http://www.w3.org/TR/2016/NOTE-UNDERSTANDING-WCAG20-20160317/keyboard-operation-all-funcs.html">
						Understanding Success Criterion 2.1.3 (Keyboard (No Exception))
					</a></li></ul></li></ul><div class="ua-issues"><h2 class="small-head" id="ua10.14.1"> User Agent and Assistive Technology Support Notes</h2><p>See <a href="/WAI/WCAG20/Techniques/ua-notes/silverlight#SL14">User Agent Support Notes for SL14</a>. Also see <a href="silverlight_notes.html">Silverlight Technology Notes</a>.</p></div><h2 id="SL14-description">Description</h2><div class="textbody"><p>The objective of this technique is to implement built-in handling
    				of key events in a custom control. If a custom control is correctly
    				implemented, then any Silverlight applications that include the control
    				can rely on the built-in key handling for some or all of the desired
    				keyboard equivalence of a control's functionality. </p><p>Defining a custom control requires that the control author write a
    				default template for the control and also the initialization logic,
    				including the default implementations for built-in keyboard equivalence.
    				Typically, control authors provide keyboard equivalence for any actions
    				that can be activated by a mouse click on the control surface, and
    				that are not already providing a keyboard equivalence through the implementation
    				of a composite part. </p><p>All input events report a specific source that is communicated to
    				handler code as an event parameter, so that the application author
    				can identify which element in their Silverlight UI was being interacted
    				with, and the application can perform an action that is relevant to
    				that user input. In the case of mouse events, the event source is the
    				element that the mouse pointer is over at the time. In the case of
    				key events, the event source is the element that has focus. The element
    				that has focus is visually indicated so that the user knows which element
    				they are interacting with (see <a href="SL2.html"><em>SL2: Changing The Visual Focus Indicator in Silverlight</em></a>). Assistive technologies
    				often have parallel conventions whereby the user is made aware of which
    				element is visually focused and is the current input scope presented
    				by the assistive technology. </p><div id="SL14_hosts"><h4> Browser hosts and keyboard events </h4><p>Silverlight is hosted as a plug-in inside a browser host. The Silverlight
    					runtime only receives the input events that the browser host forwards
    					to hosted plug-ins through a browser-specific program access layer.
    					Occasionally the browser host receives input that the browser host
    					itself handles in some way, and does not forward the keyboard event.
    					An example is that a Silverlight application hosted by an Internet
    					Explorer browser host on Windows operating system cannot detect a press
    					of the ALT key, because Internet Explorer processes this input and
    					performs the action of bringing keyboard focus to the Internet Explorer
    					menu bar. Silverlight authors might need to be aware of browser-specific
    					input handling models and not rely on key events for keys that are
    					essentially reserved for use by a browser host. For more information,
    					see <a href="https://msdn.microsoft.com/en-us/library/cc189015(VS.95).aspx">Keyboard
    						Support</a>. </p><p>Application authors should choose keys that avoid browser conflicts,
    					but still are a natural choice for an accelerator. Using the CTRL key
    					as a modifier is a convention that is frequently used in existing Silverlight
    					applications. </p></div><div id="SL14_which-keys"><h4> Informing users of which keys to use for keyboard equivalence </h4><p>If a control supports user interaction, which key to use to engage
    					the keyboard equivalent behavior is not always obvious. One way to
    					inform users of the possible key options that a control supports is
    					to author an <code>AutomationProperties.HelpText</code> value in
    					the application UI that gives instructions such as "Press the
    					plus key to increment value". This is up to the application author
    					to do; the control definitions do not provide a means to set HelpText
    					by default, because any display technique for end user help is potentially
    					too application-specific to be encapsulated in control definitions.
    					Application authors might also consider using tooltips, providing a
    					menu framework that visually indicates the key associations (perhaps
    					with the Windows key-underlined convention), providing a generalized
    					application Help, or displaying plain text in the user interface. </p></div><div id="SL14_on-methods"><h4> The On* method pattern in Silverlight </h4><p>Silverlight classes often have methods that follow the naming pattern <code>On*</code> where
    					the star is a string that also identifies an event. These <code>On*</code> methods
    					are prewired event handlers, defined as virtual methods so that subclasses
    					can override them. A consumer of a control class can change or augment
    					the default behavior associated with that event by overriding the method,
    					and typically also calls the base implementation so that the base functionality
    					is preserved. This principle is illustrated in Example 1 by the overrides
    					of <code>OnGotFocus</code> and <code>OnLostFocus</code>. Controls that introduce new events should
    					consider also exposing a virtual <code>On*</code> method that pairs with the event,
    					so that consumers of the custom control can use the same pattern. </p></div></div><h2 class="small-head" id="SL14-examples">Examples</h2><h3 class="small-head" id="SL14-ex1">Example 1: KeyNumericUpDown Control That Handles Arrow Key Equivalence
    					for + and - Buttons</h3><div class="example"><div class="textbody"><p>This example implements a custom Silverlight control that displays
    						an integer value, and can increment or decrement the integer value
    						based on user actions. When a user interacts with the control, the
    						user can click the "+" and "-" buttons that are
    						component parts of the control. The "+" and "-" button
    						parts are deliberately not in the Silverlight tab sequence, because
    						this is intended to be a complete control, where only the control itself
    						(and not its constituent parts) are focusable and are reported as an
    						element to the accessibility framework. To provide keyboard equivalence,
    						the control defines a <code>KeyUp</code> handler. The design of
    						the control treats an Up Arrow key press as equivalent to activating
    						the "+" button, and the Down Arrow key as equivalent to activating
    						the "-" button. The control implementation reinforces this
    						behavior by having the button <code>Click</code> event handlers
    						and the cases of the <code>KeyUp</code> handler call the same underlying
    						helper functions (Increment() and Decrement()). </p><p>Handling the + and - keys as alternate or additional keyboard equivalents
    						for the actions is also possible (if that is desired, handler would
    						check for <code>Key.Add</code> or <code>Key.Subtract</code> values). </p><p>The following is the XAML-defined control template for this control.</p><div class="code"><pre><code>   &lt;Style TargetType="local:KeysNumericUpDown"&gt;
       &lt;Setter Property="BorderThickness" Value="1"/&gt;
       &lt;Setter Property="Height" Value="22"/&gt;
       &lt;Setter Property="BorderBrush"&gt;
           &lt;Setter.Value&gt;
               &lt;LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0"&gt;
                   &lt;GradientStop Color="#FFA3AEB9" Offset="0"/&gt;
                   &lt;GradientStop Color="#FF8399A9" Offset="0.375"/&gt;
                   &lt;GradientStop Color="#FF718597" Offset="0.375"/&gt;
                   &lt;GradientStop Color="#FF617584" Offset="1"/&gt;
               &lt;/LinearGradientBrush&gt;
           &lt;/Setter.Value&gt;
       &lt;/Setter&gt;
       &lt;Setter Property="Template"&gt;
           &lt;Setter.Value&gt;
               &lt;ControlTemplate TargetType="local:KeysNumericUpDown"&gt;
                   &lt;Grid x:Name="CompositionRoot"&gt;
                       &lt;Grid.ColumnDefinitions&gt;
                           &lt;ColumnDefinition/&gt;
                           &lt;ColumnDefinition/&gt;
                       &lt;/Grid.ColumnDefinitions&gt;
                       &lt;TextBox x:Name="Text" IsTabStop="False" AcceptsReturn="False"
 BorderThickness="0" Foreground="{TemplateBinding Foreground}" FontWeight="{TemplateBinding FontWeight}"
 FontStyle="{TemplateBinding FontStyle}" FontStretch="{TemplateBinding FontStretch}"
 FontSize="{TemplateBinding FontSize}" FontFamily="{TemplateBinding FontFamily}" MinWidth="20"
 TextAlignment="Right" VerticalAlignment="Center"  TextWrapping="NoWrap" Text="{TemplateBinding Value}"&gt;
                               &lt;TextBox.Style&gt;
                                   &lt;Style TargetType="TextBox"&gt;
                                       &lt;Setter Property="Template"&gt;
                                           &lt;Setter.Value&gt;
                                               &lt;ControlTemplate TargetType="TextBox"&gt;
                                                   &lt;ScrollViewer x:Name="ContentElement" BorderThickness="0" Padding="0"/&gt;
                                               &lt;/ControlTemplate&gt;
                                           &lt;/Setter.Value&gt;
                                       &lt;/Setter&gt;
                                   &lt;/Style&gt;
                               &lt;/TextBox.Style&gt;
                           &lt;/TextBox&gt;
                       &lt;StackPanel Orientation="Vertical" Grid.Column="1"&gt;
                       &lt;Button Width="18" Height="18" IsTabStop="False" x:Name="plusButton"&gt;+&lt;/Button&gt;
                       &lt;Button Width="18" Height="18" IsTabStop="False" x:Name="minusButton"&gt;-&lt;/Button&gt;
                       &lt;/StackPanel&gt;
                       &lt;Border x:Name="FocusVisualElement" BorderBrush="#FF45D6FA" BorderThickness="{TemplateBinding BorderThickness}" 
                       CornerRadius="1,1,1,1" IsHitTestVisible="False" Opacity="0"/&gt;
                   &lt;/Grid&gt;
               &lt;/ControlTemplate&gt;
           &lt;/Setter.Value&gt;
       &lt;/Setter&gt;
   &lt;/Style&gt;
   </code></pre></div><p>The following is the implementation of the control class. Overrides
    						of the base class are omitted for clarity, as is automation support.
    						Note the event wiring in <code>OnApplyTemplate</code>; this is
    						a common pattern for custom control definitions. </p><div class="code"><pre><code>   public class KeysNumericUpDown : UpDownBase&lt;double&gt;
   {
       Grid root;
       Button plusButton;
       Button minusButton;
       Border focusRect;
       public KeysNumericUpDown()
       {
           this.DefaultStyleKey = typeof(KeysNumericUpDown);
       }
       public override void OnApplyTemplate()
       {
           base.OnApplyTemplate();
           root = this.GetTemplateChild("CompositionRoot") as Grid;
           root.KeyUp += new KeyEventHandler(Handle_Accelerators);
           plusButton = this.GetTemplateChild("plusButton") as Button;
           minusButton = this.GetTemplateChild("minusButton") as Button;
           plusButton.Click += new RoutedEventHandler(plusButton_Click);
           minusButton.Click += new RoutedEventHandler(minusButton_Click);
           focusRect = this.GetTemplateChild("FocusVisualElement") as Border;
       }
       void plusButton_Click(object sender, EventArgs e)
       {
           Increment();
       }
       void minusButton_Click(object sender, EventArgs e)
       {
           Decrement();
       }
       private void Increment()
       {
           this.Value += 1;
       }
       private void Decrement()
       {
           this.Value -= 1;
       }
       private void Handle_Accelerators(object sender, KeyEventArgs e)
       {
           switch (e.Key)
           {
               case (Key.Up):
                   this.Value -= 1;
                   e.Handled = true;
                   break;
               case (Key.Down):
                   this.Value += 1;
                   e.Handled = true;
                   break;
               default: break;
           }
       }
       protected override void OnGotFocus(RoutedEventArgs e)
       {
           base.OnGotFocus(e);
           if (focusRect != null)
           {
               focusRect.Opacity = 1;
           }
       }
       protected override void OnLostFocus(RoutedEventArgs e)
       {
           base.OnLostFocus(e);
           focusRect.Opacity = 0;
       }
   }
   </code></pre></div><p>When this control is included in application UI, the usage is very
    						simple. Note that there are no key handlers on this instance; the
    						necessary key handling to wire up the increment/decrement logic is
    						already built-in to all instances of the control. </p><div class="code"><pre><code>&lt;local:KeysNumericUpDown Width="100" Height="45"/&gt;
</code></pre></div><p>This example is shown in operation in the <a href="/WAI/WCAG20/Techniques/working-examples/SL14/SimpleNumericUpDownTestPage.html" class="ex-ref">working example of Numeric Up / Down control</a>.</p></div></div><h2 id="SL14-resources">Resources</h2><div class="textbody"><p>Resources are for information purposes only, no endorsement implied.</p><ul><li><p>
                  <a href="https://msdn.microsoft.com/en-us/library/cc189015(VS.95).aspx">Keyboard
    					Support</a> 
               </p></li><li><p>
                  <a href="https://msdn.microsoft.com/en-us/library/cc903954(VS.95).aspx">Focus
    					Overview</a> 
               </p></li><li><p>
                  <a href="https://msdn.microsoft.com/en-us/library/cc278064(VS.95).aspx">Creating
    					a New Control by Creating a ControlTemplate</a> 
               </p></li><li><p>
                  <a href="https://msdn.microsoft.com/en-us/library/cc189018(VS.95).aspx">Events
    						Overview for Silverlight</a> 
               </p></li></ul></div><h2 id="SL14-related-techs">Related Techniques</h2><div class="textbody"><ul><li><a href="G90.html">G90: Providing keyboard-triggered event handlers</a></li><li><a href="SL9.html">SL9: Handling Key Events to Enable Keyboard Functionality in Silverlight</a></li><li><a href="SL19.html">SL19: Providing User Instructions With AutomationProperties.HelpText in
    			Silverlight</a></li></ul></div><h2 id="SL14-tests">Tests</h2><div class="textbody"><h3 class="small-head" id="SL14-procedure">Procedure</h3><ol class="enumar"><li><p> Using a browser that supports Silverlight, open an HTML page that
    					references a Silverlight application through an object tag. </p></li><li><p> Press TAB key to move keyboard focus to various element parts
    						of the user interface, and in particular to areas that are known
    						to be custom control implementations. </p></li><li><p> Check that custom key commands exist for all these user interface
    							actions and that these key commands are made known to the user. </p></li></ol><h3 class="small-head" id="SL14-results">Expected Results</h3><p>#3 is true. </p><p>If this is a sufficient technique for a success criterion, failing this test procedure does not necessarily mean that the success criterion has not been satisfied in some other way, only that this technique has not been successfully implemented and can not be used to claim conformance.</p></div><!-- BOTTOM NAVIGATION BAR --><ul id="navigationbottom"><li><strong><a href="#top">Top</a></strong></li><li><strong><a href="Overview.html#contents" title="Table of Contents">Contents</a></strong></li><li><strong><a href="intro.html" title="Introduction to Techniques for WCAG 2.0"><abbr title="Introduction">Intro</abbr></a></strong></li><li><a title="SL13: Providing A Style Switcher To Switch To High Contrast" href="SL13.html"><strong>Previous: </strong>
        Technique SL13</a></li><li><a title="SL15: Providing Keyboard Shortcuts that Work Across the Entire Silverlight&#xA;    &#x9;&#x9;&#x9;Application" href="SL15.html"><strong>Next: </strong>
        Technique SL15</a></li></ul><div class="footer"><p class="copyright">This Web page is part of <a href="Overview.html">Techniques and Failures for Web Content Accessibility Guidelines 2.0</a> (see the <a href="http://www.w3.org/TR/WCAG20-TECHS/SL14.html">latest version of this document</a>). The entire document is also available as a <a href="complete.html">single HTML file</a>. See the <a href="http://www.w3.org/WAI/intro/wcag20">The WCAG 2.0 Documents</a> for an explanation of how this document fits in with other Web Content Accessibility Guidelines (WCAG) 2.0 documents. To send public comments, please follow the <a href="http://www.w3.org/WAI/WCAG20/comments/">Instructions for Commenting on WCAG 2.0 Documents</a>.
 </p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p></div></body></html>